# -*- coding: utf-8 -*-
import tkinter as tk
from tkinter import ttk, messagebox
import json, os, sys, datetime, subprocess

def resource_path(rel_path):
    base = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base, rel_path)

STATE_FILE = resource_path(".grid_state.json")
LOG_FILE = resource_path("dashboard.log")
SETTINGS_FILE = resource_path("settings.json")
UPDATER_PATH = os.path.abspath(os.path.join(resource_path(".."), "..", "updater"))

DEFAULT_SETTINGS = {
    "theme": "light",
    "sidebar": True,
    "modules": [{"active": True, "name": f"Modul {i+1}", "icon": ""} for i in range(12)],
    "font_size": 12,
    "n_cols": 4,
    "n_rows": 3
}

class Logger:
    def __init__(self, textbox, footer):
        self.textbox = textbox
        self.footer = footer

    def log(self, msg, color="black"):
        timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        full_msg = f"[{timestamp}] {msg}"
        self.textbox.insert(tk.END, full_msg + '\\n')
        self.textbox.see(tk.END)
        self.footer.config(text=msg, foreground=color)
        with open(LOG_FILE, "a") as f:
            f.write(full_msg + '\\n')

class SteelCoreDashboard(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Steel-Core Dashboard")
        self.geometry("1280x900")
        self.drag_data = {"widget": None, "x": 0, "y": 0}
        self.modules = []
        self.module_checks = []
        self.settings = self.load_settings()
        self.theme = self.settings.get("theme", "light")
        self.n_cols = self.settings.get("n_cols", 4)
        self.n_rows = self.settings.get("n_rows", 3)
        self.logger = None
        self.tooltip = None

        try:
            self.setup_ui()
            self.check_for_updates()
        except Exception as e:
            self.fatal_error("Fehler beim Start", e)

    def load_settings(self):
        if os.path.exists(SETTINGS_FILE):
            try:
                with open(SETTINGS_FILE) as f:
                    s = json.load(f)
                for k, v in DEFAULT_SETTINGS.items():
                    if k not in s:
                        s[k] = v
                if "modules" in s:
                    if isinstance(s["modules"][0], dict):
                        while len(s["modules"]) < DEFAULT_SETTINGS["n_cols"] * DEFAULT_SETTINGS["n_rows"]:
                            s["modules"].append({"active": True, "name": f"Modul {len(s['modules'])+1}", "icon": ""})
                    else:
                        new_mods = []
                        for i, act in enumerate(s["modules"]):
                            new_mods.append({"active": act, "name": f"Modul {i+1}", "icon": ""})
                        s["modules"] = new_mods
                return s
            except Exception:
                return DEFAULT_SETTINGS.copy()
        else:
            return DEFAULT_SETTINGS.copy()

    def save_settings(self):
        try:
            with open(SETTINGS_FILE, "w") as f:
                json.dump(self.settings, f, indent=2)
        except Exception as e:
            print(f"Fehler beim Schreiben der Einstellungen: {e}")

    def setup_ui(self):
        self.create_header()
        self.create_sidebars()
        self.create_main()
        self.create_footer()
        self.configure_theme()
        self.bind_shortcuts()
        self.load_positions()
        self.set_module_visibility()
        self.logger.log("GUI und Einstellungen geladen.", "green")

    def create_header(self):
        self.header = ttk.Frame(self)
        self.header.pack(fill=tk.X)
        self.status_label = ttk.Label(self.header, text="Status: Starte...", font=("Arial", 14, "bold"))
        self.status_label.pack(side=tk.LEFT, padx=10)
        ttk.Button(self.header, text="A+", command=self.increase_fontsize).pack(side=tk.RIGHT, padx=2)
        ttk.Button(self.header, text="A‚Äì", command=self.decrease_fontsize).pack(side=tk.RIGHT, padx=2)
        ttk.Button(self.header, text="üîÑ Theme", command=self.toggle_theme).pack(side=tk.RIGHT, padx=2)
        ttk.Button(self.header, text="üíæ Save", command=self.save_positions).pack(side=tk.RIGHT)

    def create_sidebars(self):
        self.sidebar_left = ttk.Frame(self)
        self.sidebar_left.pack(side=tk.LEFT, fill=tk.Y)
        ttk.Label(self.sidebar_left, text="Module anzeigen:", font=("Arial", 11, "bold")).pack(pady=5)
        self.module_vars = []
        for i, mod in enumerate(self.settings["modules"]):
            v = tk.BooleanVar(value=mod.get("active", True))
            cb = ttk.Checkbutton(self.sidebar_left, text=mod.get("name", f"Modul {i+1}"), variable=v, command=self.set_module_visibility)
            cb.pack(anchor="w")
            self.module_vars.append(v)
            self.module_checks.append(cb)
        ttk.Separator(self.sidebar_left).pack(fill=tk.X, pady=8)
        ttk.Button(self.sidebar_left, text="üß∞ Update-Manager", command=self.toggle_updater).pack(pady=4)
        ttk.Button(self.sidebar_left, text="‚èπÔ∏è Sidebar", command=self.toggle_sidebar).pack(pady=4)
        ttk.Button(self.sidebar_left, text="‚ÑπÔ∏è Hilfe (F1)", command=self.show_help).pack(pady=4)

    def create_main(self):
        main_frame = ttk.Frame(self)
        main_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=6, pady=8)
        self.grid_area = ttk.Frame(main_frame)
        self.grid_area.pack(fill=tk.BOTH, expand=True)
        self.grid_area.bind("<Configure>", self.on_grid_resize)

        font_size = self.settings.get("font_size", 12)
        self.modules = []
        for i in range(self.n_rows):
            for j in range(self.n_cols):
                idx = i * self.n_cols + j
                if idx < len(self.settings["modules"]):
                    modset = self.settings["modules"][idx]
                    name = modset.get("name", f"Modul {idx+1}")
                    icon = modset.get("icon", "")
                else:
                    name, icon = f"Modul {idx+1}", ""
                text = f"{icon} {name}".strip()
                mod = tk.Label(self.grid_area, text=text, bg="#f0f0f0", relief="raised", bd=1, font=("Arial", font_size, "bold"))
                mod.grid(row=i, column=j, sticky="nsew", padx=5, pady=5)
                mod.bind("<ButtonPress-1>", self.on_drag_start)
                mod.bind("<B1-Motion>", self.on_drag_motion)
                mod.bind("<ButtonRelease-1>", self.on_drag_release)
                mod.bind("<FocusIn>", lambda e, m=mod: m.config(highlightbackground="#00aaff", highlightthickness=2))
                mod.bind("<FocusOut>", lambda e, m=mod: m.config(highlightthickness=0))
                mod.bind("<Enter>", lambda e, ix=idx: self.show_tooltip(ix))
                mod.bind("<Leave>", lambda e: self.hide_tooltip())
                mod.focus_set()
                self.modules.append(mod)
        for i in range(self.n_rows):
            self.grid_area.rowconfigure(i, weight=1)
        for j in range(self.n_cols):
            self.grid_area.columnconfigure(j, weight=1)
        log_frame = ttk.Frame(main_frame)
        log_frame.pack(side=tk.RIGHT, fill=tk.Y)
        ttk.Label(log_frame, text="üìã Log-Ausgabe").pack()
        self.log_box = tk.Text(log_frame, width=38, height=32, font=("Consolas", 10))
        self.log_box.pack()
        self.footer_ref = None
        self.logger = Logger(self.log_box, None)
        self.tooltip = None

    def create_footer(self):
        footer = ttk.Frame(self)
        footer.pack(fill=tk.X)
        for i in range(4):
            ttk.Label(footer, text=f"F{i+1}").grid(row=0, column=i, sticky="ew")
            footer.columnconfigure(i, weight=1)
        self.footer_status = ttk.Label(footer, text="", anchor="w")
        self.footer_status.grid(row=0, column=4, sticky="ew")
        self.logger.footer = self.footer_status

    def bind_shortcuts(self):
        self.bind("<F1>", lambda e: self.show_help())
        self.bind("<Escape>", lambda e: self.destroy())
        self.bind("<Control-plus>", lambda e: self.increase_fontsize())
        self.bind("<Control-minus>", lambda e: self.decrease_fontsize())
        self.bind("<Tab>", self.focus_next_widget)

    def focus_next_widget(self, event):
        event.widget.tk_focusNext().focus()
        return "break"

    def show_help(self):
        messagebox.showinfo("Hilfe", 
            "Steel-Core Dashboard\n"
            "- Theme wechseln: üîÑ Button oben rechts\n"
            "- Module umbenennen: settings.json bearbeiten\n"
            "- Module verschieben: Drag & Drop mit Maus\n"
            "- Modul aktivieren/deaktivieren: Sidebar-Checkliste\n"
            "- Updates pr√ºfen: automatisch beim Start, manuell via Update-Manager\n"
            "- Tastatur: Tab = N√§chstes Feld, ESC = Schlie√üen, F1 = Hilfe\n"
        )

    def on_grid_resize(self, event):
        w = self.grid_area.winfo_width()
        h = self.grid_area.winfo_height()
        mod_w = w // self.n_cols - 12
        mod_h = h // self.n_rows - 12
        for idx, mod in enumerate(self.modules):
            i, j = divmod(idx, self.n_cols)
            mod.config(width=mod_w, height=mod_h)

    def toggle_theme(self):
        themes = ["light", "dark", "high_contrast"]
        ix = themes.index(self.theme)
        self.theme = themes[(ix+1)%len(themes)]
        self.settings["theme"] = self.theme
        self.configure_theme()
        self.logger.log(f"Theme gewechselt zu: {self.theme}", "blue")
        self.save_settings()

    def increase_fontsize(self):
        self.settings["font_size"] = min(self.settings.get("font_size", 12) + 2, 28)
        for widget in self.modules:
            widget.config(font=("Arial", self.settings["font_size"], "bold"))
        self.logger.log("Font-Size erh√∂ht.")
        self.save_settings()

    def decrease_fontsize(self):
        self.settings["font_size"] = max(self.settings.get("font_size", 12) - 2, 8)
        for widget in self.modules:
            widget.config(font=("Arial", self.settings["font_size"], "bold"))
        self.logger.log("Font-Size verkleinert.")
        self.save_settings()

    def set_module_visibility(self):
        for i, v in enumerate(self.module_vars):
            self.settings["modules"][i]["active"] = v.get()
            self.modules[i].grid_remove() if not v.get() else self.modules[i].grid()
        self.logger.log("Modul-Sichtbarkeit aktualisiert.", "blue")
        self.save_settings()

    def toggle_sidebar(self):
        if self.sidebar_left.winfo_ismapped():
            self.sidebar_left.pack_forget()
            self.settings["sidebar"] = False
        else:
            self.sidebar_left.pack(side=tk.LEFT, fill=tk.Y)
            self.settings["sidebar"] = True
        self.logger.log("Sidebar-Sichtbarkeit umgeschaltet.", "blue")
        self.save_settings()

    def check_for_updates(self):
        try:
            info_path = os.path.join(UPDATER_PATH, "info-stand.txt")
            applied = []
            if os.path.isfile(info_path):
                with open(info_path) as f:
                    for line in f:
                        if line.startswith("Update"):
                            applied.append(line.split()[1])
            available = sorted(f for f in os.listdir(UPDATER_PATH) if f.startswith("create_steelcore_skeleton_update_") and f.endswith(".sh"))
            missing = []
            for file in available:
                uid = file.split("_")[-1].replace(".sh", "")
                if uid not in applied:
                    missing.append(file)
            if missing:
                self.status_label.config(text=f"‚ö†Ô∏è {len(missing)} Updates verf√ºgbar!", foreground="orange")
                self.logger.log(f"{len(missing)} Updates gefunden: {missing}", "orange")
                self.after(1800, lambda: self.auto_notify_updates(missing))
            else:
                self.status_label.config(text="‚úÖ Alles aktuell.", foreground="green")
                self.logger.log("Update-Pr√ºfung: System ist aktuell.", "green")
        except Exception as e:
            self.status_label.config(text="‚ùå Fehler bei Update-Pr√ºfung", foreground="red")
            self.logger.log(f"Fehler bei Update-Pr√ºfung: {e}", "red")

    def auto_notify_updates(self, missing):
        msg = "Folgende Updates k√∂nnen installiert werden:\\n" + "\\n".join(missing) + "\\n\\nJetzt anwenden?"
        if messagebox.askyesno("Neue Updates gefunden!", msg):
            for file in missing:
                path = os.path.join(UPDATER_PATH, file)
                try:
                    subprocess.run(["bash", path], check=True)
                    self.logger.log(f"‚úÖ {os.path.basename(file)} erfolgreich installiert.", "green")
                except subprocess.CalledProcessError as e:
                    self.logger.log(f"‚ùå Fehler beim Anwenden von {file}: {e}", "red")
            self.status_label.config(text="‚úÖ Alle Updates angewendet!", foreground="green")
        else:
            self.status_label.config(text=f"‚ö†Ô∏è Updates √ºbersprungen.", foreground="orange")

    def toggle_updater(self):
        update_window = tk.Toplevel(self)
        update_window.title("Update-Manager")
        update_window.geometry("650x480")
        ttk.Label(update_window, text="Verf√ºgbare Updates", font=("Arial", 12)).pack(pady=10)
        frame = ttk.Frame(update_window)
        frame.pack(fill=tk.BOTH, expand=True)
        info_path = os.path.join(UPDATER_PATH, "info-stand.txt")
        applied = []
        if os.path.isfile(info_path):
            with open(info_path) as f:
                for line in f:
                    if line.startswith("Update"):
                        applied.append(line.split()[1])
        updates = sorted(f for f in os.listdir(UPDATER_PATH) if f.startswith("create_steelcore_skeleton_update_") and f.endswith(".sh"))
        if not updates:
            ttk.Label(frame, text="Keine Updates gefunden.").pack(pady=10)
        for up in updates:
            uid = up.split("_")[-1].replace(".sh", "")
            path = os.path.join(UPDATER_PATH, up)
            status = "‚úÖ" if uid in applied else "üü°"
            color = "#16d916" if uid in applied else "#fab600"
            b = ttk.Button(frame, text=f"{status} {up}", command=lambda p=path: self.run_update_script(p))
            b.pack(fill=tk.X, padx=10, pady=3)
            b.config(style="Accent.TButton")
        if any(uid not in applied for uid in [f.split("_")[-1].replace(".sh", "") for f in updates]):
            ttk.Button(frame, text="üí• Alle fehlenden Updates installieren", command=lambda: self.auto_notify_updates([f for f in updates if f.split("_")[-1].replace(".sh", "") not in applied])).pack(pady=8)

    def run_update_script(self, script_path):
        try:
            subprocess.run(["bash", script_path], check=True)
            self.logger.log(f"‚úÖ {os.path.basename(script_path)} ausgef√ºhrt.", "green")
        except subprocess.CalledProcessError as e:
            self.logger.log(f"‚ùå Fehler beim Ausf√ºhren von {script_path}: {e}", "red")

    def configure_theme(self):
        bg = "#222" if self.theme == "dark" else "#fff"
        fg = "#eee" if self.theme == "dark" else "#000"
        font_size = self.settings.get("font_size", 12)
        for widget in self.modules:
            widget.config(bg=bg, fg=fg, font=("Arial", font_size, "bold"))
        self.log_box.config(bg="#222" if self.theme=="dark" else "#f8f8f8", fg=fg)
        self.status_label.config(background=bg, foreground=fg)
        self.footer_status.config(background=bg, foreground=fg)
        self.save_settings()

    def save_positions(self):
        try:
            state = [{"row": idx // self.n_cols, "col": idx % self.n_cols, "text": m.cget("text")} for idx, m in enumerate(self.modules)]
            with open(STATE_FILE, "w") as f:
                json.dump(state, f)
            self.logger.log("üìå Positionen gespeichert.", "green")
        except Exception as e:
            self.fatal_error("Fehler beim Speichern", e)

    def load_positions(self):
        if os.path.exists(STATE_FILE):
            try:
                with open(STATE_FILE, "r") as f:
                    state = json.load(f)
                for saved, widget in zip(state, self.modules):
                    widget.grid(row=saved["row"], column=saved["col"])
                self.logger.log("‚Ü©Ô∏è Positionen geladen.", "blue")
            except Exception as e:
                self.logger.log("‚ö†Ô∏è Layout konnte nicht geladen werden.", "red")
                self.logger.log(str(e), "red")

    def on_drag_start(self, event):
        self.drag_data["widget"] = event.widget
        self.drag_data["x"] = event.x
        self.drag_data["y"] = event.y

    def on_drag_motion(self, event):
        pass # Drag im Grid noch nicht implementiert

    def on_drag_release(self, event):
        self.drag_data["widget"] = None

    def show_tooltip(self, ix):
        if ix < len(self.settings["modules"]):
            modset = self.settings["modules"][ix]
            txt = f"{modset.get('name','Modul')} ‚Äì {'aktiv' if modset.get('active') else 'inaktiv'}"
        else:
            txt = f"Modul {ix+1}"
        if self.tooltip: self.tooltip.destroy()
        x = self.modules[ix].winfo_rootx() + 40
        y = self.modules[ix].winfo_rooty() + 40
        self.tooltip = tw = tk.Toplevel(self.modules[ix])
        tw.wm_overrideredirect(True)
        tw.wm_geometry(f"+{x}+{y}")
        label = tk.Label(tw, text=txt, background="#fffc84", relief="solid", borderwidth=1, font=("Arial", 12))
        label.pack()

    def hide_tooltip(self):
        if self.tooltip:
            self.tooltip.destroy()
            self.tooltip = None

    def fatal_error(self, msg, err):
        import traceback
        traceback.print_exc()
        messagebox.showerror("Fehler", f"{msg}: {err}")
        self.logger and self.logger.log(f"‚ùå {msg}: {err}", "red")
        self.destroy()

if __name__ == "__main__":
    app = SteelCoreDashboard()
    app.mainloop()
